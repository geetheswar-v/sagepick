generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String            @id
  name          String
  email         String
  emailVerified Boolean           @default(false)
  image         String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @default(now()) @updatedAt
  sessions      Session[]
  accounts      Account[]
  mediaRatings  UserMediaRating[] // User's ratings and watchlist

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model Media {
  id             String       @id @default(cuid())
  title          String
  alt_titles     String[]     @default([])
  synopsis       String?
  type           MediaType
  provider_id    String
  provider_type  ProviderType
  cover_image    String?
  backdrop_image String?
  status         String?
  year           Int?
  score          Float?       @default(0)
  genres         String[]     @default([])
  tags           String[]     @default([])
  countries      String[]     @default([])
  languages      String[]     @default([])
  adult          Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relations
  categories  MediaCategory[]
  animeData   AnimeData?
  mangaData   MangaData?
  userRatings UserMediaRating[]

  @@unique([provider_id, provider_type])
  @@index([type])
  @@index([provider_type])
  @@index([score])
  @@index([year])
  @@map("media")
}

// Anime-specific data (Jikan)
model AnimeData {
  media_id    String   @id
  anime_type  String? // TV, ONA, Special, Movie, etc
  episodes    Int?
  duration    String?
  season      String?
  airing      Boolean? @default(false)
  airing_from String? // Start date
  airing_to   String? // End date
  studios     String[] @default([])
  rating      String? // Age rating (G, PG, PG-13, R, R+, Rx)

  // Relations
  media Media @relation(fields: [media_id], references: [id], onDelete: Cascade)

  @@map("anime_data")
}

// Manga-specific data (MangaDex)
model MangaData {
  media_id                String  @id
  last_chapter            String?
  last_volume             String?
  rating                  String? // Content rating (safe, suggestive, erotica, pornographic)
  publication_demographic String? // Publication demographic (shounen, seinen, shoujo, josei, none)

  // Relations
  media Media @relation(fields: [media_id], references: [id], onDelete: Cascade)

  @@map("manga_data")
}

// User rating system for recommendation data
model UserMediaRating {
  id        String       @id @default(cuid())
  user_id   String
  media_id  String
  rating    Float // User's personal rating (1-10)
  status    MediaStatus? // watching, completed, dropped, etc
  progress  Int? // Episodes watched, chapters read
  notes     String? // Personal notes
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  // Relations
  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)
  media Media @relation(fields: [media_id], references: [id], onDelete: Cascade)

  @@unique([user_id, media_id]) // One rating per user per media
  @@index([user_id])
  @@index([media_id])
  @@index([rating])
  @@map("user_media_rating")
}

model MediaCategory {
  id             String   @id @default(cuid())
  media_id       String
  category_title String // "Trending Movies", "Top K-Dramas", "Popular Web Series"
  position       Int // Position within that category
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  media Media @relation(fields: [media_id], references: [id], onDelete: Cascade)

  @@unique([media_id, category_title]) // One media per category title
  @@index([category_title, position])
  @@index([category_title, createdAt])
  @@map("media_category")
}

// Job tracking for sync operations
model SyncJob {
  id          String        @id @default(cuid())
  jobType     SyncJobType
  status      SyncJobStatus @default(RUNNING)
  startedAt   DateTime      @default(now())
  completedAt DateTime?
  errorMsg    String?
  itemsTotal  Int?          @default(0)
  itemsSync   Int?          @default(0)
  metadata    Json? // Additional job-specific data

  logs SyncLog[]

  @@index([jobType, startedAt])
  @@index([status])
  @@map("sync_job")
}

// Detailed logging for sync operations
model SyncLog {
  id        String   @id @default(cuid())
  jobId     String
  level     LogLevel @default(INFO)
  message   String
  details   Json?
  createdAt DateTime @default(now())

  job SyncJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId, createdAt])
  @@index([level])
  @@map("sync_log")
}

// Track hourly sync state for pagination
model SyncState {
  id            String   @id @default(cuid())
  syncType      String   @unique // "sync-movies", "sync-tv", "sync-anime", "sync-manga"
  currentPage   Int      @default(1)
  currentOffset Int      @default(0)
  totalItems    Int      @default(0)
  lastRun       DateTime @updatedAt
  metadata      Json?

  @@map("sync_state")
}

// Enums
enum MediaType {
  MOVIE
  TV
  ANIME
  MANGA
}

enum ProviderType {
  TMDB
  JIKAN
  MANGADEX
}

enum MediaStatus {
  PLANNING // Want to watch/read

  WATCHING // Currently watching
  READING // Currently reading

  COMPLETED // Finished
  PAUSED // On hold
  DROPPED // Abandoned

  REWATCHING // Watching again
  REREADING // Reading again
}

enum SyncJobType {
  // Category Jobs
  TRENDING_SYNC
  POPULAR_SYNC
  TOP_RATED_SYNC
  DRAMAS_SYNC
  UPCOMING_SYNC

  // Hourly Full Sync Jobs  
  MOVIES_SYNC
  TV_SYNC
  ANIME_SYNC
  MANGA_SYNC
}

enum SyncJobStatus {
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum LogLevel {
  DEBUG
  INFO
  WARN
  ERROR
}
